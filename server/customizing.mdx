---
title: "Customizing Your Server"
description: "How to modify generated code â€” add custom tools, adjust behavior, and extend functionality."
---

## You own the code

Generated code is yours to modify. There's no lock-in, no proprietary runtime, no SDK dependency. The server is standard Python using open-source libraries (FastMCP, httpx, Pydantic).

## Common customizations

### Adjust tool descriptions

Tool descriptions are used by AI agents to decide when to call a tool. You can improve them directly in `server.py`:

```python
@mcp.tool()
async def list_users(page: int = 1, limit: int = 10) -> dict[str, Any]:
    """List all active users with pagination.

    Use this to browse the user directory. Returns name, email, and role
    for each user. Supports pagination with page and limit parameters.
    """
```

Better descriptions lead to better tool selection by AI agents.

### Add custom tools

Add new tools directly in `server.py`:

```python
@mcp.tool()
async def my_custom_tool(query: str) -> str:
    """A custom tool that combines data from multiple endpoints."""
    users = await list_users(limit=5)
    # ... your custom logic
    return result
```

### Modify resilience settings

All resilience parameters are in `.env` and can be changed without modifying code. See [Security Features](/server/security) for all options.

### Change the base URL

Override the API base URL in `.env`:

```bash .env
BASE_URL=https://staging-api.example.com
```

Useful for switching between production, staging, and local development environments.

## Re-generating

If the original API specification is updated, you can re-generate the server from the updated specification. Your customizations in `server.py` will be overwritten, so keep custom tools in a separate file if you plan to re-generate frequently.

<Tip>
  A good pattern is to keep customizations in a wrapper file that imports from the generated server, so re-generation doesn't overwrite your changes.
</Tip>
